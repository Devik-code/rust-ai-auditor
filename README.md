# rust-ai-auditor

This project is an **AI Quality Auditor** designed to mitigate "hallucinations" or errors in code generated by Artificial Intelligence. Its main function is to validate Rust code generated by AIs using the real Rust compiler, thus ensuring the reliability and functionality of the code in enterprise environments.

An AI-generated code auditing system for Rust that allows measuring the ROI and reliability of generative AIs in a company.

## Main Features

- ü§ñ **Automatic Auditing**: Validates AI-generated Rust code using real compilation.
- üìä **Analytics**: Performance metrics and common error patterns.
- üîç **Dual API**: REST and GraphQL for flexibility.
- üõ°Ô∏è **Intelligent Validation**: Detects dangerous patterns and syntax errors.
- üìà **ROI Metrics**: Success rate, error frequency, and usage statistics.

## Architecture Diagram

```mermaid
graph TD
    A[User] --> B{GraphQL / REST API}
    B --> C[Rust Service]
    C --> D[Rust Compiler (rustc)]
    C --> E[PostgreSQL]
    D --> C
```

## Getting Started

### A) With Docker (Recommended)

This method manages the database and the application for you. It is the recommended way to have a consistent and production-ready environment.

**1. Start Services:**
Make sure you have Docker and `docker compose` installed. Then, run:
```bash
docker compose up --build -d
```
The application will be available at `http://localhost:3000`.

**2. Advanced Instructions:**
For manual commands, troubleshooting, or a deeper understanding of the Docker setup, see our **[Docker Guide](DOCKER.md)**.

### B) For Local Development (Without Docker)

This method is for developers who prefer to run the project directly on their machine.

**1. Prerequisites:**
- Install [Rust](https://www.rust-lang.org/tools/install).
- Install a [PostgreSQL](https://www.postgresql.org/download/) server locally.

**2. Database Setup:**
- Create a database named `ai_auditor` with a user `postgres` and password `password`.
- Alternatively, you can create a `.env` file in the project root and configure your `DATABASE_URL`:
  ```
  DATABASE_URL=postgres://YOUR_USER:YOUR_PASSWORD@localhost:5432/ai_auditor
  ```

**3. Run the Application:**
```bash
 cargo run
```
The application will be available at `http://localhost:3000`.

## Available Routes

| Route | Method | Description |
|-------|--------|-------------|
| `/` | GET | GraphiQL IDE (browser) |
| `/graphql` | POST | GraphQL endpoint |
| `/audit` | POST | REST API - Create audit |
| `/stats` | GET | REST API - Get analytics stats |

## REST API

### Create Audit

Create a new AI code audit record. The `is_valid` and `compilation_error` fields are automatically calculated by the validation engine.

**Endpoint:** `POST /audit`

**Request:**

```bash
curl -X POST http://localhost:3000/audit -H "Content-Type: application/json" -d '{"prompt":"Create a function that sums two numbers","generated_code":"pub fn sum(a: i32, b: i32) -> i32 { a + b }"}'
```

**Response (201 Created):**

```json
{
  "id": "bfc949cc-743c-44d5-bc94-8ada8fed8fbc",
  "prompt": "Create a function that sums two numbers",
  "generated_code": "pub fn sum(a: i32, b: i32) -> i32 { a + b }",
  "is_valid": true,
  "compilation_error": null,
  "created_at": "2026-01-13T20:02:18.213246Z"
}
```

## GraphQL API

Open `http://localhost:3000` in your browser to access the GraphiQL IDE.

### Query: List all audits

```graphql
query {
  audits {
    id
    prompt
    generatedCode
    isValid
    compilationError
    createdAt
  }
}
```

### Query: Get audit by ID

```graphql
query {
  audit(id: "bfc949cc-743c-44d5-bc94-8ada8fed8fbc") {
    prompt
    generatedCode
    isValid
    compilationError
  }
}
```

### Mutation: Create audit

```graphql
mutation {
  createAudit(input: {
    prompt: "test from graphql"
    generatedCode: "pub fn hello() { println!(\"Hello\"); }"
  }) {
    id
    isValid
    compilationError
  }
}
```

### GraphQL via curl

```bash
curl -X POST http://localhost:3000/graphql -H "Content-Type: application/json" -d '{"query":"{ audits { id isValid } }"}'
```

## Validation Rules

The code validator checks for:
- Balanced braces `{}`, parentheses `()`, and brackets `[]`
- Missing `fn main()` in standalone programs
- Dangerous patterns (`std::process::Command`, `std::fs::remove`, `unsafe`)
- Missing semicolons in `let` statements
- Empty function bodies

## Verify Data in Database

To check the stored audits:

```bash
docker exec -it rust-ai-auditor-db psql -U postgres -d ai_auditor -c "SELECT id, prompt, is_valid, created_at FROM ai_audits;"
```

## Analytics Dashboard

### REST API - Get Stats

This endpoint is crucial for companies to **measure the reliability and performance of the code generated by their AIs**. It provides key metrics that allow evaluating code quality, identifying trends, and making informed decisions about integrating AI into their development workflows.

**Endpoint:** `GET /stats`

**Request:**

```bash
curl http://localhost:3000/stats
```

**Response:**

```json
{
  "total_audits": 150,
  "valid_audits": 120,
  "invalid_audits": 30,
  "validation_rate": 0.8,
  "common_errors": [
    {
      "error_message": "cannot find type `MyType` in this scope",
      "frequency": 12
    },
    {
      "error_message": "expected one of",
      "frequency": 8
    }
  ]
}
```

### GraphQL - Stats Query

```graphql
query {
  stats {
    totalAudits
    validAudits
    invalidAudits
    validationRate
    commonErrors {
      errorMessage
      frequency
    }
  }
}
```

## ROI and Reliability Metrics

This system allows companies to:

### üìä **ROI Measurement**
- **Success Rate**: Percentage of AI code that compiles correctly.
- **Efficiency**: Reduction in manual review time.
- **Cost-Benefit**: Comparison between traditional vs. AI-assisted development.

### üõ°Ô∏è **Quality Control**
- **Error Patterns**: Systematic identification of common problems.
- **Automatic Validation**: Detection of dangerous or insecure code.
- **Traceability**: Complete record of prompts and results.

### üìà **Key Metrics**
- `validation_rate`: Percentage of valid code (main quality metric).
- `common_errors`: Most frequent errors for AI training.
- `total_audits`: Volume of use and adoption.

### üí° **Business Use Cases**
1. **AI Model Evaluation**: Compare performance between different models.
2. **Team Training**: Identify areas for improvement in generated code.
3. **Governance**: Ensure quality in critical projects.
4. **Prompt Optimization**: Improve instructions based on results.

## Business Integration

### Continuous Monitoring
```bash
# Stats endpoint for dashboards
GET /stats

# GraphQL for custom queries
POST /graphql
```

### Alerts and Thresholds
Companies can configure alerts based on:
- Validation rate < 80%
- New error patterns
- Anomalous volume of audits

This system provides the necessary visibility to make informed decisions about the adoption of generative AI in software development.

## üöÄ Quick Start Guide

### 1. Start the Server

```bash
# Make sure Docker is running with PostgreSQL
docker start rust-ai-auditor-db 2>/dev/null || docker run --name rust-ai-auditor-db \
  -e POSTGRES_PASSWORD=password \
  -e POSTGRES_DB=ai_auditor \
  -p 5432:5432 \
  -d postgres

# Start the server
cargo run
```

The server will be available at http://localhost:3000

### 2. Test Immediately

**Option A: GraphiQL IDE (Recommended)**
Open http://localhost:3000 in your browser and use these queries:

```graphql
# View current statistics
query {
  stats {
    totalAudits
    validAudits
    validationRate
  }
}

# Create your first audit
mutation {
  createAudit(input: {
    prompt: "Create a function that sums two numbers"
    generatedCode: "pub fn sum(a: i32, b: i32) -> i32 { a + b }"
  }) {
    id
    isValid
    compilationError
  }
}
```

**Option B: REST API with curl**

```bash
# View statistics
curl http://localhost:3000/stats

# Create audit
curl -X POST http://localhost:3000/audit \
  -H "Content-Type: application/json" \
  -d '{ 
    "prompt": "Recursive factorial function",
    "generated_code": "pub fn factorial(n: u32) -> u32 { if n <= 1 { 1 } else { n * factorial(n-1) } }"
  }'
```

### 3. Typical Workflow

1. **Developer** creates code with AI ‚Üí sends it to `/audit`
2. **System** automatically validates with real compilation
3. **Company** reviews `/stats` to measure ROI
4. **Team** adjusts prompts based on common errors

### 4. Key Metrics to Monitor

- **validation_rate**: What percentage of AI code works?
- **common_errors**: What errors does the AI need to fix?
- **total_audits**: How much is the system being used?

### 5. Verification in Database

```bash
# View latest audits
docker exec -it rust-ai-auditor-db psql -U postgres -d ai_auditor \
  -c "SELECT prompt, is_valid, created_at FROM ai_audits ORDER BY created_at DESC LIMIT 5;"
```

Done! Now you have real metrics on the performance of AI-generated code.
